# Build OpenKNX Release Overviews for Integration in Pages, Wiki and Toolbox
# (C) 2025 Cornelius KÃ¶pp; For Usage in OpenKNX-Project only
from datetime import datetime, timedelta, timezone
import json
import logging
import os
import defusedxml.ElementTree as ET  # secure replacement for  import xml.etree.ElementTree as ET
import zipfile
from io import BytesIO

from app_sizing_stat import AppSizingStat  # Add this import
from dependency_manager import DependencyManager
from devices_helper import DeviceHelper
from github_client import GitHubClient
from html_generator import HTMLGenerator
from release_manager import ReleaseManager

# Initialize logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Enable caching for requests if the directory exists
cache_path = '.github_cache'
if os.path.isdir(cache_path):
    import requests_cache

    # logging.getLogger("requests_cache").setLevel(logging.DEBUG)
    expire_after = 3 * 24 * 60 * 60
    logging.info(f"Local DEV using .github_cache (expire_after={expire_after/60/60}h)")
    requests_cache.install_cache(cache_path, backend='filesystem', expire_after=expire_after)

# names for identification of app repos:
appPrefix = "OAM-"
appSpecialNames = {"SOM-UP", "GW-REG1-Dali", "SEN-UP1-8xTH", "BEM-GardenControl"}
appExclusion = {"OAM-TestApp"}
appOrder = [

    # virtual only modules
    "OAM-LogicModule",
    "OAM-StateEngine",
    "OAM-ShutterController",

    # virtual with optional hardware
    "OAM-PresenceModule",
    "OAM-VirtualButton",
    "OAM-Meter",

    # universal sensor hardware
    "OAM-SensorModule",
    "SEN-UP1-8xTH",

    # gateways to other systems
    "GW-REG1-Dali",
    "OAM-InfraredGateway",
    "OAM-OneWireModule",
    "OAM-EnoceanGateway",
    # "OAM-EnoceanGateway_V2"
    "OAM-ModbusGateway",
    "OAM-Aircondition",

    # gateways with ip
    "OAM-Sonos",
    "OAM-Homematic",

    # network
    "OAM-IP-Router",
    "OAM-InternetServices",
    "OAM-SmartHomeBridge",

    # dummy-app only
    "OAM-Dummy",

    # special hardware
    "OAM-WeatherWN90LP",
    "SOM-UP",
    "OAM-AccessControl",
    "BEM-GardenControl",
    "OAM-TouchRound",

    # "boring" hardware
    "OAM-REG1-Schaltaktor-4x",
    "OAM-SwitchActuator",
    "OAM-BinaryInput",
    "OAM-HeatingActuator",
    "OAM-LedDimmer-AB",

    # very, very special
    "OAM-ElectricDoorDrive",
    "OAM-BinaryClock",
]

client = GitHubClient()
release_manager = ReleaseManager(client, appPrefix, appSpecialNames, appExclusion)
dependency_manager = DependencyManager(client)
device_helper = DeviceHelper()
html_generator = HTMLGenerator(device_helper)




def process_release_zip(zip_url):
    content_xml_paths = ['data\\content.xml', 'data/content.xml']

    response = client.get_response(zip_url)
    zipfile_obj = zipfile.ZipFile(BytesIO(response.content))

    app_stat = None
    hardware_info = None

    # Check for app xml to read parameter-memory-size
    xml_files = [name for name in zipfile_obj.namelist() if name.endswith('.xml') and name not in content_xml_paths]
    if len(xml_files) != 1:
        logging.warning(f"Found {len(xml_files)} other XML files in the archive {zip_url}, expected only one: {xml_files}")
    else:
        app_xml = xml_files[0]
        logging.debug(f"Analyse '{app_xml}' as App-XML")
        with zipfile_obj.open(app_xml) as xml_file:
            app_stat = AppSizingStat(xml_file)
            logging.debug(f"Sizing in '{app_xml}': {app_stat}")

    # needs to check windows-path as found in zip generated by OpenKNX-Build-Process
    content_xmls = [name for name in content_xml_paths if name in zipfile_obj.namelist()]
    if len(content_xmls) == 0:
        logging.warning(f"No 'data\\content.xml' or 'data/content.xml' found in the archive {zip_url}")
    else:
        # [[WORK-AROUND]] try to fix for wrong encoding, some releases contains utf-16le:
        try:
            with zipfile_obj.open(content_xmls[0]) as xml_file:
                xml_content = xml_file.read().decode('utf-8')
        except UnicodeDecodeError:
            with zipfile_obj.open(content_xmls[0]) as xml_file:
                logging.warning(f"((>>WORKAROUND<<)) 'content.xml' not UTF-8 encoded, try fall-back to wrong UTF-16LE: {zip_url}")
                xml_content = xml_file.read().decode('utf-16le')

        # [[WORK-AROUND]] quick-fix for older releases with broken XML:
        xml_str = xml_content.replace('<Products>\r\n</Content>', '</Products>\r\n</Content>')
        if xml_str != xml_content:
            logging.warning(f"((>>WORKAROUND<<)) Quick-Fixed broken XML in 'content.xml' found in the archive {zip_url}")

        try:
            root = ET.fromstring(xml_str)
            hardware_info = [product.get('Name') for product in root.find('Products')]
        except ET.ParseError as e:
            logging.error(f"'content.xml' parsing failed in the archive {zip_url}")
            # TODO check hard ending?!

    return hardware_info, app_stat


def process_releases(releases_data):
    hardware_mapping = {}
    oam_stat = {}
    for oam, oam_data in releases_data.items():
        oam_releases = oam_data["releases"]
        if not oam_releases or not isinstance(oam_releases, list) or len(oam_releases) == 0:
            logging.warning(f"No releases found for {oam}")
            continue
        latest_release = oam_releases[0]
        for asset in latest_release.get('assets', []):
            ## TODO check all?
            logging.info(f"Fetching release archive {oam} from {asset['browser_download_url']}")

            hardware_info, app_stat = process_release_zip(asset['browser_download_url'])
            if app_stat is not None:
                oam_stat[oam] = app_stat
            if hardware_info is not None:
                hardware_mapping[oam] = hardware_info
                break ## TODO check

        else:
            logging.warning(f"No assets found for {oam}")
    return hardware_mapping, oam_stat


def generate_oam_data(oam_dependencies, oam_hardware, oam_details):
    logging.debug(f"OAM Hardware {oam_hardware}")

    oam_data = {}
    for oam, dependencies in oam_dependencies.items():
        oam_data[oam] = {
            "description": oam_details.get(oam, {}).get("description", "(keine Kurzbeschreibung)"),
            "modules": dependencies,
            "devices": [],  # set empty list for OAMs without releases # TODO check cleanup of data-collection
        }
        if oam not in oam_details:
            logging.warning(f"Missing {oam} in oam_details, present only {oam_details.keys()}")
    for oam, oam_device_list in oam_hardware.items():
        if oam in oam_data:
            oam_data[oam]["devices"] = oam_device_list
        else:
            logging.warning(f"Missing {oam} in oam_data, present only {oam_data.keys()}")

    logging.debug(f"oam_data {json.dumps(oam_data, indent=4)}")

    # Sort based on given order, all others at end
    oam_data_sorted = {oam: oam_data[oam] for oam in appOrder if oam in oam_data}
    oam_data_unsorted = {oam: oam_data[oam] for oam in oam_data if oam not in appOrder}
    return {**oam_data_sorted, **oam_data_unsorted}


def main():
    oam_repos = release_manager.fetch_app_repos()

    delta = timedelta(hours=4, minutes=45)
    now = datetime.now(timezone.utc)
    oam_updated = {
        repo["name"]: repo["updated_at"]
        for repo in oam_repos
        if (now - datetime.strptime(repo["updated_at"], "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)) <= delta
    }
    if len(oam_updated) == 0:
        logging.info(f"No repos have been updated in the last {delta} => NO need for updates!")
        return # no need to update for unchanged OAM-repos
    logging.info(f"The {len(oam_updated)} following repos have been updated in the last {delta}: {oam_updated}")

    # release-data (base) for usage in openknx-toolbox
    oam_releases_data = release_manager.fetch_apps_releases(oam_repos)

    oam_hardware_raw, oam_stat = process_releases(oam_releases_data)
    with open('hardware_mapping_raw.json', 'w') as outfile:
        json.dump(oam_hardware_raw, outfile, indent=4)

    oam_hardware = {
        oam: [device_helper.hw_name_mapping(oam, d) for d in oam_device_list]
        for oam, oam_device_list in oam_hardware_raw.items()
    }
    with open('hardware_mapping.json', 'w') as outfile:
        json.dump(oam_hardware, outfile, indent=4)

    for oam, oam_data in oam_releases_data.items():
        oam_data["hw_avail_open"] = sum(1 for name in oam_hardware.get(oam, []) if device_helper.is_open_device(name))

    releases_data = {
        "OpenKnxContentType": "OpenKNX/OAM/Releases",
        "OpenKnxFormatVersion": "v0.2.0",
        "data": oam_releases_data
    }
    with open(os.path.join("docs", 'releases.json'), 'w') as outfile:
        json.dump(releases_data, outfile, indent=4)
    # logging.info(f"OAM Release Data: {json.dumps(oam_releases_data, indent=4)}")

    # app statistics
    for oamName, oamStat in oam_stat.items():
        logging.info(f"App-Sizing-Stat for {oamName}: {oamStat}")

    html_generator.update_html(oam_releases_data)
    all_oam_dependencies = dependency_manager.fetch_all_dependencies(oam_repos)

    # Generate Dependencies Table
    oam_data = generate_oam_data(all_oam_dependencies, oam_hardware, oam_releases_data)
    html_generator.update_overview_tables(oam_data)


if __name__ == "__main__":
    main()
